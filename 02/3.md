## 2.3 变量

- 变量声明方式：
- 1. var声明方式:
    - 格式：```var <name> [type] [=value]```
    - 解析：
        1. name: 变量名
        2. type: 变量类型
        3. =: 等号
        4. value: 变量值。
    - 其中类型和值二者可以省略一个。
        - 省略类型的时候，会从值推导出变量的类型。
        - 省略值的时候，会使用类型的零值初始化，
            - 其中整型为0，布尔为false，字符串为空串。结构体类型则为各个字段的零值。引用类型为空，包括slice/map/chan等。
            - 这样做的意义，防止未经定义的变量出现未定义的行为，避免了像c/c++等的未初始化变量的未定义的行为。
    - 示例:
        ```go
        var s string // s 被初始化为空字符串""
        var i, j, k int // i/j/k为变量列表，都是int类型，初始化为0
        var b, f, s = true, 2.3, "four" // b/f/s为变量列表，类型不同，分别推导为：bool/float64/string

        type A struct {
            s []int
            m map[int]string
            c chan int
            b B
        }

        type B struct {
            a int
            b string
        }

        var a A // a为A类型，其中引用类型用nil初始化，b为结构体类型，则会递归初始化B内部的元素。
        ```
    - 初始化时机：
        - 包级别的变量，在main函数执行前初始化。
        - 局部变量初始化和声明都在函数执行期间进行。
        - 变量可以通过函数返回值进行初始化。
        ```go
        var f, err = os.Open(name) // os.Open()返回一个文件和一个错误
        ```

### 2.3.1 短变量声明

- 在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。采用的格式：
    - 格式: name := expression
    - name的类型由表达式的类型决定。
- 特点：
    - 短小、灵活，故在局部变量色声明和初始化中主要使用它。
    - var声明(局部变量)
        - 通常是为那些初始化表达式类型不一致的局部变量保留的。
        - 或者用于后面才对变量赋值
        - 以及变量初始值不重要的情况。
        - 示例:
        ```go
        func hello() {
            i := 100
            var boiling float64 = 100 // 100为整型，而boiling为float64，这种情况必须使用var形式。
            var names []string // 后面才对变量赋值。
            var err error // 初始值不重要。
            ...
            names = append(names, "hello")
            err = fmt.Errorf("hello, world")
        }
        ```
- 声明和初始化也可以用多个变量列表的方式声明并初始化:
    ```go
    i, j := 0, 1
    ```
    - 只在当它们对于可读性有帮助的时候才使用多个初始化表达式进行变量声明，如for循环初始化。
- 声明为(:=)，赋值为(=)
- 和var一样，也可以用函数返回值来声明：
    ```go
    f, err := os.Open(name)
    ```
- ***注意***: 短变量声明不需要声明所有左边的变量。如果一些变量在作用域内之前已经声明过了，那么对于这些变量短声明等价于赋值。
    ```go
    in, err := os.Open(inFile)
    //...
    out, err := os.Open(outFile) // 其中err在之前已经声明过了，这里等同于赋值。
    ```
    - 短变量声明至少声明一个变量，否则无法通过编译。
    - ???
### 2.3.2 指针

- 并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址
- *p(p是指针类型)，可以出现在等号右边，用于赋值。出现在等号左边，表示修改对应p所指向内存的对象的值。
- 任何类型的指针的零值都是nil
- 指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
    ```go
    var x, y int
    fmt.Println(&x == &x, &x == &y, &x == nil) // true, false, false
    ```
- 返回函数中局部变量的地址也是安全的，这点和c不同，需要注意。
    ```go
    var p = f()

    func f() *int {
        v := 1
        return &v
    }

    fmt.Println(f() == f()) // "false"
    ```
    - 函数返回的局部变量地址，每次调用都返回不同的地址，这个需要注意。

- 指针作为函数参数，可以在函数内部修改指针所指向的对象的值。
    
    ```go
    func incr(p *int) int {
        *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
        return *p
    }

    v := 1
    incr(&v)              // side effect: v is now 2
    fmt.Println(incr(&v)) // "3" (and v is 3)
    ```
    - 其中```*p++```并不推荐这种写法，这里是模拟c语言的写法。

- 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名
- 指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：
    - 要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）
- 不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。

- flag包，典型的使用指针作为返回值。通过命令行参数来获取对应的选项。
    - flag.Bool()函数，三个参数，选项(命令行)，默认值，以及帮助说明字符。函数返回bool类型变量指针。注意这里只能返回指针。可以思考一下原因。
    - flag.String()函数，同样也是三个参数，选项(命令行)，默认值，以及帮助说明字符串。同样返回字符串指针。
    - 在main函数开头调用，flag.Parse()后，会解析命令行参数，分别对应到flag.Bool()和flag.String()的返回值。
    - 没有调用flag.Parse()之前，对应的返回值是默认值。调用之后，会根据命令行参数匹配，如果匹配上了，就用命令行参数替换对应的值，否则不变。
    - 没有匹配上的参数，可以使用flag.Args()返回一个字符串切片。
    - 如果在flag.Parse函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序
    - 示例:
    ```go
    package main

    import (
        "flag"
        "fmt"
        "strings"
    )

    var n = flag.Bool("n", false, "omit trailing newline")
    var sep = flag.String("s", " ", "separator")

    func main() {
        flag.Parse() // 解析命令行参数。
        fmt.Print(strings.Join(flag.Args(), *sep))
        if !*n {
            fmt.Println()
        }
    }
    // $ go build echo4.go
    // $ ./echo4 a bc def
    // a bc def
    // $ ./echo4 -s / a bc def
    // a/bc/def
    // $ ./echo4 -n a bc def
    // a bc def
    // $ ./echo4 -help
    // Usage of ./echo4:
    //   -n	omit trailing newline
    //   -s string
    //      separator (default " ")
    ```

### 2.3.3 new函数
- 调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
    ```go
    p := new(int)   // p, *int 类型, 指向匿名的 int 变量
    fmt.Println(*p) // "0"
    *p = 2          // 设置 int 匿名变量的值为 2
    fmt.Println(*p) // "2"
    ```
- 用new创建变量和普通变量声明语句方式创建变量没有什么区别
- 除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)
    - 换言之，new函数类似是一种语法糖，而不是一个新的基础概念
    - 下面的代码有着相同的行为：
    ```go
    func newInt() *int {
        return new(int)
    }

    func newInt() *int {
        var dummy int
        return &dummy
    }
    ```
- 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
    ```go
    p := new(int)
    q := new(int)
    fmt.Println(p == q) // "false"
    ```
    - 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）
    ```go 
    p := new(struct{})
	q := new(struct{})

	fmt.Print(p == q)
	// $ go version
	// go version go1.19.1 darwin/amd64
	// $ ./zero_type
	// false
    ```
    - 译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）
    - 这部分作为后续的学习内容。

- new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活
- 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：
    ```go
    func delta(old, new int) int { return new - old }
    ```
    - 注意，在函数内部，不能在适应new函数了。

### 2.3.4. 变量的生命周期
- 变量的生命周期指的是在程序运行期间变量有效存在的时间段
    - 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
    - 而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
    - 一个小的编程技巧(奇技淫巧)：
        ```go
        for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        ```
        - 译注：函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样：
        ```go 
        for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(
                size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
            )               // 小括弧另起一行缩进，和大括弧的风格保存一致
        }
        ```
    - 在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。
    - 那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？
        - 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
        - 因为一个变量的有效周期只取决于是否可达，因此:
            - 一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。
            - 同时，局部变量可能在函数返回之后依然存在。(个人理解的逃逸现象，如函数返回局部变量的地址)
        - 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。这点需要注意，var并不一定就在栈上，new也不一定就在堆上。
        ```go
        var global *int

        func f() {
            var x int
            x = 1
            global = &x
        }

        func g() {
            y := new(int)
            *y = 1
        }
        ```
        - 分析上面的代码：
            - f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。
            - 相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。
            - 其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

        - 因此需要注意以下几点：
            - Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。
            - 你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。
            - 例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。


