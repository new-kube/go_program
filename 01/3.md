## 1.3 找出重复的行

- 用于文件复制、打印、检索、排序、统计的程序，通常有一个相似的结构：
    - 在输入接口上循环读取，然后对每一个元素进行一些计算，在运行时或者在最后输出结果。
- 我们展示一个dup程序，受UNIX的uniq命令启发，来找到相邻的重复行。

- map的使用方法:
    ```go
    counts := make(map[string]int) 
    // 1. 构造一个map，key类为string，value是int
    counts["hello"]++   
    // 2. 这个操作等价于: 
    //  counts["hello"] = counts["hello"] + 1
    //  等号右边的counts["hello"]在没有这个key的时候，会自动添加零值，即 counts["hello"] = 0
    
    // 3. map作为参数传递的时候，其实是传递的是map的引用的值，所以，函数内部的改动，会在函数外面可见。
    // 4. map的迭代顺序，每次并不固定，这个是有意为之，防止依赖特定的key的顺序。
    ```
- os.File有对应的Read/Write方法，当时大多数时候很少需要调用这么低级别的函数，通常我们使用高级别的函数(对低级别函数进行封装)，这样使用起来更加方便。
